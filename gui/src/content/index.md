# Lossy Time Series Compression for Electrophysiology

With the increasing sizes of data for extracellular electrophysiology, it is crucial to develop efficient methods for compressing multi-channel time series data. While lossless methods are desirable for perfectly preserving the original signal, the compression ratios for these methods usually range only from 2-4x. What is needed are ratios on the order of 10-30x, leading us to consider lossy methods.

In this site, we explore and analyze three methods for lossy compression of time series data which we call:

- Quantized Fourier Compression (QFC)
- Quantized Wavelet Compression (QWC)
- Quantized Time Domain Compression (QTC)

All three methods involve the following steps for compression:

- Transform the time series data to a different domain (or keep them in the time domain for QTC)
- Quantize the transformed data in order to lower the information energy (this is where the loss occurs)
- Compress the quantized data using a lossless method such as zlib

Then to reconstruct an approximation of the original signal, the following steps are taken:

- Decompress the quantized data
- Transform the data back to the time domain (or keep them in the time domain for QTC)

For QFC, the transform is the Discrete Fourier Transform (DFT), for QWC it is the Discrete Wavelet Transform (DWT), and for QTC it is the identity transformation. In all cases, quantization involves the choice of a quantization step size, which is a tradeoff between the compression ratio and the error introduced by quantization. The entropy of the system then determines the theoretically achievable compression ratio. The different lossless compression methods (e.g., zlib, ZStandard) will be evaluated to see how close they can get to this theoretical limit.

**Compression of a Gaussian Signal**

We will start by analyzing the compression of a random Gaussian signal with a known noise level. For simplicity, we will start with the Quantized Time Domain Compression (QTC) method.

Let $x_1, x_2, \ldots, x_N$ be the original signal, and $\hat{x}_1, \hat{x}_2, \ldots, \hat{x}_N$ be the quantized approximation of the signal. So we have

$$
\hat{x}_i = \lfloor x_i / q \rceil \cdot q
$$

where $q$ is the quantization step size and $\lfloor \cdot \rceil$ is the rounding operation. The normalized root mean square error (NRMSE) between the original and reconstructed signal is then given by

$$
D(x, \hat{x}) = \frac{1}{\sigma}\sqrt{\frac{1}{N}\sum_{i=1}^{N} (x_i - \hat{x}_i)^2}
$$

where $\sigma$ is the noise level in the original signal. We are interested in the tradeoff between the compression ratio and this error introduced by quantization. As mentioned, the theoretically possible compression ratio is determined by the information entropy. We will assume that the samples are independent and identically distributed (i.i.d.) and that the noise level of the Gaussian signal is $\sigma$. The entropy of a single sample (in bits) is

$$
H_0 = -\sum_{j \in \mathbb{Z}} p(j) \log_2 p(j)
$$

where

$$
p(j) = \frac{1}{\sqrt{2\pi}\sigma} \int_{(j - 0.5)q}^{(j + 0.5)q} e^{-x^2 / 2\sigma^2} dx
$$

$$
=\frac{1}{2}\,\Biggl[
  \mathrm{erf}\!\Bigl(\frac{(j + 0.5)q}{\sqrt{2}\sigma}\Bigr)
  \;-\;
  \mathrm{erf}\!\Bigl(\frac{(j - 0.5)q}{\sqrt{2}\sigma}\Bigr)
\Biggr].
$$

is the probability of the sample having a value at step $j$. The entropy of the signal, or the theoretical required storage size in bits, is then $H = NH_0$ and the theoretical compression ratio is $16 / H_0$, assuming that the original signal is stored as 16-bit integers.

Figure 1 shows a plot of the theoretical compression ratio for a Gaussian signal as a function of the NRMSE for the QTC method together with the actual compression ratios achieved by the lossless compression methods zlib, ZStandard, and LZMA. The graph is generated by varying the quantization step size $q$ from 0.01 to 4 in steps of 0.01 and calculating the NRMSE and compression ratios for each step size.

```python
# generate-plot
import numpy as np
from scipy.special import erf

def p_function(i, q, sigma):
    return 0.5 * (erf((i + 0.5) * q / (2**0.5 * sigma)) - erf((i - 0.5) * q / (2**0.5 * sigma)))

def entropy_per_sample(q, sigma):
    v = round(sigma / q * 20)
    return -sum(p_function(i, q, sigma) * np.log2(p_function(i, q, sigma)) for i in range(-v, v + 1) if p_function(i, q, sigma) > 0)

def theoretical_compression_ratio(q, sigma):
    return 16 / entropy_per_sample(q, sigma)

def nrmse(q, sigma):
    x = np.arange(-5 * sigma, 5 * sigma, 0.01)
    p = np.exp(-x**2 / (2 * sigma**2)) / (np.sqrt(2 * np.pi) * sigma)
    p = p / np.sum(p)
    xhat = np.round(x / q) * q
    return np.sqrt(np.sum((x - xhat)**2 * p) / sigma**2)

def simulated_nrmse(q, sigma):
    N = 1000
    signal = np.random.normal(0, sigma, N)
    quantized_signal = np.round(signal / q) * q
    return np.sqrt(np.mean((signal - quantized_signal)**2) / sigma**2)

def simulated_compression_ratio(*, q, sigma, lossless_method='zlib'):
    N = 1000
    signal = np.random.normal(0, sigma, N)
    quantized_signal_ints = np.round(signal / q).astype(np.int32)
    buf = quantized_signal_ints.tobytes()

    if lossless_method == 'zlib':
        import zlib
        compressed = zlib.compress(buf, level=9)
    elif lossless_method == 'zstandard':
        import zstandard
        cctx = zstandard.ZstdCompressor(level=22)
        compressed = cctx.compress(buf)
    elif lossless_method == 'lzma':
        import lzma
        compressed = lzma.compress(buf, preset=9)
    else:
        raise ValueError('Invalid lossless method')
    return N * 2 / len(compressed)

qs = np.arange(0.01, 4, 0.01)
theoretical_compression_ratios = [theoretical_compression_ratio(q, 1) for q in qs]
actual_compression_ratios_zlib = [simulated_compression_ratio(q=q, sigma=1, lossless_method='zlib') for q in qs]
actual_compression_ratios_zstandard = [simulated_compression_ratio(q=q, sigma=1, lossless_method='zstandard') for q in qs]
actual_compression_ratios_lzma = [simulated_compression_ratio(q=q, sigma=1, lossless_method='lzma') for q in qs]
nrmses = [nrmse(q, 1) for q in qs]
simulated_nrmses = [simulated_nrmse(q, 1) for q in qs]

import matplotlib.pyplot as plt
plt.figure()
plt.plot(nrmses, theoretical_compression_ratios, label='Theoretical')
plt.plot(nrmses, actual_compression_ratios_zlib, label='Zlib')
plt.plot(nrmses, actual_compression_ratios_zstandard, label='Zstandard')
plt.plot(nrmses, actual_compression_ratios_lzma, label='LZMA')
plt.xlabel('NRMSE')
plt.ylabel('Compression Ratio')
plt.legend()
plt.semilogy()
plt.grid(True, which='both', axis='y', linestyle='--')
plt.title('QTC Compression Ratio vs. NRMSE for Gaussian Signal')
plt.show()
```

In this case, the actual compression ratios are significantly lower than the theoretical limit. This is due to that fact that the available lossless methods are suboptimal when the data are random, as they are designed to work with recurring patterns in the data, such as is the case for images and text. The ideal method would be arithmetic coding, which is unfortunately very difficult to implement efficiently in practice.

Now let's consider some [real electrophysiology data](https://neurosift.app/?p=/nwb&url=https://api.dandiarchive.org/api/assets/c04f6b30-82bf-40e1-9210-34f0bcd8be24/download/&dandisetId=000409&dandisetVersion=draft):

```python
# generate-plot
import numpy as np
import requests
import io

def load_real_1(*, num_samples: int, num_channels: int, start_channel: int) -> np.ndarray:
    url = f'https://lindi.neurosift.org/tmp/ephys-compression/real_1_{num_samples}_{start_channel}_{num_channels}.npy'
    response = requests.get(url)
    response.raise_for_status()
    return np.load(io.BytesIO(response.content))

signal = load_real_1(num_samples=5000, num_channels=1, start_channel=101)

import matplotlib.pyplot as plt
timestamps = np.arange(len(signal)) / 30000
plt.figure(figsize=(10, 5))
plt.plot(timestamps, signal)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Sample Ephys Signal')
plt.show()
```

Here's the QTC compression ratio vs. NRMSE plot for the real data:

```python
# generate-plot
import numpy as np
import requests
import io
from scipy.special import erf

def p_function(i, q, sigma):
    return 0.5 * (erf((i + 0.5) * q / (2**0.5 * sigma)) - erf((i - 0.5) * q / (2**0.5 * sigma)))

def entropy_per_sample(q, sigma):
    v = round(sigma / q * 20)
    return -sum(p_function(i, q, sigma) * np.log2(p_function(i, q, sigma)) for i in range(-v, v + 1) if p_function(i, q, sigma) > 0)

def theoretical_compression_ratio(q, sigma):
    return 16 / entropy_per_sample(q, sigma)

def nrmse(*, signal, q, noise_level):
    xhat = np.round(signal / q) * q
    return np.sqrt(np.sum((signal - xhat)**2) / len(signal) / noise_level**2)

def get_compression_ratio(*, signal, q, lossless_method='zlib'):
    quantized_signal_ints = np.round(signal / q).astype(np.int32)
    buf = quantized_signal_ints.tobytes()

    if lossless_method == 'zlib':
        import zlib
        compressed = zlib.compress(buf, level=9)
    elif lossless_method == 'zstandard':
        import zstandard
        cctx = zstandard.ZstdCompressor(level=22)
        compressed = cctx.compress(buf)
    elif lossless_method == 'lzma':
        import lzma
        compressed = lzma.compress(buf, preset=9)
    else:
        raise ValueError('Invalid lossless method')
    return len(signal) * 2 / len(compressed)

def estimate_noise_level(array: np.ndarray, *, sampling_frequency: float) -> float:
    array_filtered = highpass_filter(array, sampling_frequency=sampling_frequency, lowcut=300)
    MAD = float(np.median(np.abs(array_filtered.ravel() - np.median(array_filtered.ravel()))) / 0.6745)
    return MAD

def lowpass_filter(array, *, sampling_frequency, highcut) -> np.ndarray:
    from scipy.signal import butter, lfilter

    nyquist = 0.5 * sampling_frequency
    high = highcut / nyquist
    b, a = butter(5, high, btype="low")
    return lfilter(b, a, array, axis=0)  # type: ignore


def highpass_filter(array, *, sampling_frequency, lowcut) -> np.ndarray:
    from scipy.signal import butter, lfilter

    nyquist = 0.5 * sampling_frequency
    low = lowcut / nyquist
    b, a = butter(5, low, btype="high")
    return lfilter(b, a, array, axis=0)  # type: ignore


def bandpass_filter(array, *, sampling_frequency, lowcut, highcut) -> np.ndarray:
    from scipy.signal import butter, lfilter

    nyquist = 0.5 * sampling_frequency
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(5, [low, high], btype="band")
    return lfilter(b, a, array, axis=0)  # type: ignore

def load_real_1(*, num_samples: int, num_channels: int, start_channel: int) -> np.ndarray:
    url = f'https://lindi.neurosift.org/tmp/ephys-compression/real_1_{num_samples}_{start_channel}_{num_channels}.npy'
    response = requests.get(url)
    response.raise_for_status()
    return np.load(io.BytesIO(response.content))

signal = load_real_1(num_samples=1000, num_channels=1, start_channel=101)
signal = (signal.ravel() - np.median(signal.ravel())).astype(np.int16)

qs = np.arange(0.1, 40, 0.1)
estimated_noise_level = estimate_noise_level(signal, sampling_frequency=30000)
actual_compression_ratios_zlib = [get_compression_ratio(signal=signal, q=q, lossless_method='zlib') for q in qs]
actual_compression_ratios_zstandard = [get_compression_ratio(signal=signal, q=q, lossless_method='zstandard') for q in qs]
actual_compression_ratios_lzma = [get_compression_ratio(signal=signal, q=q, lossless_method='lzma') for q in qs]
nrmses = [nrmse(signal=signal, q=q, noise_level=estimated_noise_level) for q in qs]

import matplotlib.pyplot as plt
plt.figure()
plt.plot(nrmses, actual_compression_ratios_zlib, label='Zlib')
plt.plot(nrmses, actual_compression_ratios_zstandard, label='Zstandard')
plt.plot(nrmses, actual_compression_ratios_lzma, label='LZMA')
plt.xlabel('NRMSE')
plt.ylabel('Compression Ratio')
plt.legend()
plt.semilogy()
plt.grid(True, which='both', axis='y', linestyle='--')
plt.title('QTC Compression Ratio vs. NRMSE for Real Ephys Example')
plt.show()
```

Here's the signal we're working with:

---

_All calculations for this site are computed live in your browser using [Pyodide](https://pyodide.org/), a Python runtime for the web._
